{"version":3,"file":"raw.macro.js","sources":["../src/macro.js"],"sourcesContent":["const path = require(\"path\");\nconst fs = require(\"fs\");\nconst { createMacro } = require(\"babel-plugin-macros\");\n\nmodule.exports = createMacro(rawMacros);\n\nconst RAW_DYNAMIC_VARIABLE_NAME_PREFIX = \"__raw_dynamic__\";\n\nfunction rawMacros({ references, state, babel }) {\n  // we define counter here so it always starts from 0 for different file\n  // we use object so we can mutate inside requireRaw\n  let usageCounter = {\n    value: 0,\n  };\n\n  references.default.forEach((referencePath) => {\n    if (referencePath.parentPath.type === \"CallExpression\") {\n      requireRaw({ referencePath, state, babel, usageCounter });\n    } else {\n      throw new Error(\n        `This is not supported: \\`${referencePath\n          .findParent(babel.types.isExpression)\n          .getSource()}\\`. Please see the raw.macro documentation`,\n      );\n    }\n  });\n}\n\nfunction requireRaw({ referencePath, state, babel, usageCounter }) {\n  const filename = state.file.opts.filename;\n  const t = babel.types;\n  const callExpressionPath = referencePath.parentPath;\n  const dirname = path.dirname(filename);\n  let rawPath;\n\n  const arg = callExpressionPath.get(\"arguments\")[0];\n\n  switch (arg.node.type) {\n    case \"TemplateLiteral\": {\n      const { expressions, quasis } = arg.node;\n\n      // No expressions means no dynamic values, so we can treat it\n      // the same way as string literal\n      if (expressions.length === 0) {\n        rawPath = quasis[0].value.raw;\n        break;\n      }\n\n      try {\n        // Try to evaluate template literal, in case it's a constant\n        // https://github.com/pveyes/raw.macro/issues/43\n        rawPath = callExpressionPath.get(\"arguments\")[0].evaluate().value;\n\n        if (rawPath !== undefined) {\n          break;\n        }\n      } catch (err) {}\n\n      const isInvalidTemplateLiteral = quasis[0].value.raw === \"\";\n      if (isInvalidTemplateLiteral) {\n        throw new Error(\n          \"Invalid value, variable interpolation can't be at the start of template literal\",\n        );\n      }\n\n      if (expressions.length > 2) {\n        throw new Error(\n          \"Invalid value. You can only have 2 dynamic values max. 1 for directory name, 1 for file name.\",\n        );\n      }\n\n      const dynamicVariableName =\n        RAW_DYNAMIC_VARIABLE_NAME_PREFIX + usageCounter.value;\n      usageCounter.value++;\n\n      const variables = expressions.map((node, idx) => {\n        const isDirectory =\n          idx === quasis.length - 1\n            ? false\n            : arg.node.quasis[idx + 1].value.raw.startsWith(\"/\");\n        return {\n          name: node.name,\n          isDirectory,\n        };\n      });\n\n      const rootDir = path.join(dirname, quasis[0].value.raw);\n      const pathEntries = fs\n        .readdirSync(rootDir)\n        .filter((p) => {\n          try {\n            return (\n              fs.lstatSync(path.join(rootDir, p)).isDirectory() ===\n              variables[0].isDirectory\n            );\n          } catch (err) {\n            return false;\n          }\n        })\n        .flatMap((p) => {\n          if (!variables[0].isDirectory) {\n            if (p.endsWith(quasis[1].value.raw)) {\n              return p.replace(quasis[1].value.raw, \"\");\n            } else {\n              return [];\n            }\n          }\n\n          return p;\n        });\n\n      // start from index 1 because index 0 is always base directory\n      quasis.slice(1).forEach((quasi, i) => {\n        const pathFragment = quasi.value.raw;\n        const variable = variables[i];\n\n        if (variable.isDirectory) {\n          pathEntries.forEach((traversedPath, j) => {\n            if (!quasi.tail) {\n              const traversedDirname = path.join(rootDir, traversedPath);\n              const paths = fs.readdirSync(traversedDirname).filter((p) => {\n                // quasi loop happen after .slice(1) call which means next quasi is\n                // i+2 instead of i+1\n                return p.endsWith(quasis[i + 2].value.raw);\n              });\n\n              pathEntries[j] = [traversedPath, paths];\n            }\n          });\n        }\n      });\n\n      const programPath = getProgramPath(referencePath);\n      programPath.unshiftContainer(\n        \"body\",\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            t.identifier(dynamicVariableName),\n            createObjectASTFromPathEntries(\n              t,\n              pathEntries,\n              rootDir,\n              quasis[quasis.length - 1].value.raw,\n            ),\n          ),\n        ]),\n      );\n\n      callExpressionPath.replaceWith(\n        t.expressionStatement(\n          variables.reduce((acc, variable) => {\n            return t.memberExpression(acc, t.identifier(variable.name), true);\n          }, t.identifier(dynamicVariableName)),\n        ),\n      );\n      return;\n    }\n    case \"StringLiteral\":\n      rawPath = arg.node.value;\n      break;\n  }\n\n  if (rawPath === undefined) {\n    throw new Error(\n      `There was a problem evaluating the value of the argument for the code: ${callExpressionPath.getSource()}. ` +\n        `If the value is dynamic, please make sure that its value is statically deterministic.`,\n    );\n  }\n\n  const fullPath = require.resolve(rawPath, { paths: [dirname] });\n  const fileContent = fs.readFileSync(fullPath, { encoding: \"utf-8\" });\n\n  callExpressionPath.replaceWith(\n    t.expressionStatement(t.stringLiteral(fileContent)),\n  );\n}\n\nfunction createObjectASTFromPathEntries(\n  t,\n  pathEntries,\n  rootDir,\n  fileName = \"\",\n) {\n  const objectProperties = pathEntries\n    .map((entry) => {\n      if (Array.isArray(entry)) {\n        return t.objectProperty(\n          t.stringLiteral(entry[0]),\n          createObjectASTFromPathEntries(\n            t,\n            entry[1],\n            path.join(rootDir, entry[0]),\n            fileName,\n          ),\n        );\n      }\n\n      try {\n        const rawPath =\n          fileName.startsWith(\".\") && entry.endsWith(fileName)\n            ? entry\n            : entry + fileName;\n\n        // require.resolve for dynamic value works properly (in test and in actual usage)\n        // when filename is prefixed with relative path.\n        const fullPath = require.resolve(`./${rawPath}`, {\n          paths: [rootDir],\n        });\n        return t.objectProperty(\n          t.stringLiteral(entry.replace(fileName, \"\")),\n          t.stringLiteral(fs.readFileSync(fullPath, \"utf-8\")),\n        );\n      } catch (err) {\n        return null;\n      }\n    })\n    .filter(Boolean);\n\n  if (objectProperties.length === 0) {\n    throw new Error(\n      `Cannot resolve file ${fileName} in these directories: ${pathEntries.join(\n        \", \",\n      )}`,\n    );\n  }\n\n  return t.objectExpression(objectProperties);\n}\n\nfunction getProgramPath(path) {\n  if (path.parentPath) {\n    return getProgramPath(path.parentPath);\n  }\n\n  return path;\n}\n"],"names":["path","require","fs","createObjectASTFromPathEntries","t","pathEntries","rootDir","fileName","objectProperties","map","entry","Array","isArray","objectProperty","stringLiteral","join","rawPath","startsWith","endsWith","fullPath","resolve","paths","replace","readFileSync","err","filter","Boolean","length","Error","objectExpression","module","exports","createMacro","state","babel","usageCounter","value","references","forEach","referencePath","parentPath","type","findParent","types","isExpression","getSource","callExpressionPath","dirname","file","opts","filename","arg","get","node","expressions","quasis","raw","undefined","evaluate","dynamicVariableName","variables","idx","isDirectory","name","readdirSync","p","lstatSync","flatMap","slice","quasi","i","traversedPath","j","tail","traversedDirname","getProgramPath","unshiftContainer","variableDeclaration","variableDeclarator","identifier","replaceWith","expressionStatement","reduce","acc","variable","memberExpression","fileContent","encoding","requireRaw"],"mappings":"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"}